# HU-039 — Notificaciones en tiempo real para foundation_users

**Como** usuario foundation_user  
**Quiero** recibir notificaciones en tiempo real en el dashboard  
**Para** estar al tanto de eventos importantes como nuevas solicitudes de adopción, cambios de estado, y alertas que requieren atención

---

## Dependencias

- HU-001 (Next.js App Router)
- HU-005 (MUI configurado)
- HU-007 (Tailwind configurado)
- HU-016 (Sistema de traducciones configurado)
- HU-025 (Dashboard implementado)
- Tabla `notifications` creada en `db.sql` (líneas 187-202)
- Políticas RLS para `notifications` configuradas en `rls_policies.sql` (líneas 462-477)

---

## Contexto / Notas

- La tabla `notifications` ya existe en la base de datos y tiene RLS configurado.
- Los triggers `trg_adoption_request_created` y `trg_adoption_request_status_changed` ya crean notificaciones automáticamente.
- Se debe activar Realtime en Supabase para la tabla `notifications` (configuración manual en Supabase Dashboard).
- Las notificaciones deben mostrarse en dos lugares:
  1. Icono de campana en el header con menú flotante (tooltip/menú dropdown)
  2. Sección "Requiere Atención" en el dashboard (mostrar notificaciones no leídas relevantes)
- Las notificaciones deben actualizarse en tiempo real usando Supabase Realtime.
- El usuario debe poder marcar notificaciones como leídas.

### Cómo funcionan las notificaciones en la base de datos

**Estructura de la tabla `notifications`:**
- `user_id`: UUID del usuario que **recibe** la notificación (quien la ve)
- `actor_user_id`: UUID del usuario que **originó** el evento (quien causó la notificación)
- `title`: Título de la notificación
- `body`: Cuerpo/mensaje de la notificación
- `type`: Tipo de notificación (ej: 'adoption_request_created', 'adoption_status_changed')
- `data`: JSONB con datos adicionales (request_id, animal_id, foundation_id, etc.)
- `read_at`: Timestamp de cuando se marcó como leída (NULL si no está leída)

**Tipos de notificaciones creadas por los triggers:**

1. **Para el adoptante** (auto-notificación):
   - `user_id = adopter_user_id` (el adoptante recibe)
   - `actor_user_id = adopter_user_id` (el adoptante originó la acción)
   - Título: "Solicitud enviada"
   - Se crea cuando el adoptante envía una solicitud de adopción

2. **Para cada miembro de la fundación**:
   - `user_id = member_user_id` (cada miembro de la fundación recibe una)
   - `actor_user_id = adopter_user_id` (el adoptante originó la acción)
   - Título: "Nueva solicitud de adopción"
   - Se crea una notificación **por cada miembro** registrado en `foundation_members` para esa fundación
   - La función `notify_foundation_members()` busca todos los miembros y crea una notificación para cada uno

**Importante para la implementación:**
- Las notificaciones se filtran por `user_id = auth.uid()` para que cada usuario vea solo sus propias notificaciones.
- Los foundation_users verán notificaciones donde `user_id = su_user_id` y `actor_user_id = adopter_user_id` (diferentes).
- Los adoptantes verán notificaciones donde `user_id = actor_user_id` (mismo usuario, auto-notificación).
- Si una fundación no tiene miembros en `foundation_members`, no se crearán notificaciones para la fundación (solo para el adoptante).

**Verificación:**
- Ver script de diagnóstico: `docs/scripts/verify_notifications.sql`
- Para verificar que hay miembros en una fundación: `SELECT * FROM foundation_members WHERE foundation_id = 'FOUNDATION_ID'`

---

## Diseño (OBLIGATORIO si hay UI)

Referencias:
- Diseño: `docs/design/dashboard_screen.png`
- Diseño: `docs/design/dashboard_code.html`
- Design System: `docs/design/system.md`

Reglas:
- El icono de notificaciones debe mostrar un badge con el número de notificaciones no leídas.
- El menú flotante debe aparecer al hacer clic en el icono de campana.
- El menú debe mostrar las últimas notificaciones (máximo 10-15) con scroll si hay más.
- Cada notificación debe mostrar: título, cuerpo (truncado si es muy largo), y tiempo relativo (ej: "hace 5 minutos").
- Las notificaciones no leídas deben tener un indicador visual (punto azul o fondo diferente).
- La sección "Requiere Atención" debe mostrar notificaciones relevantes (filtradas por tipo o prioridad).
- Respetar jerarquía visual del diseño.
- Usar tokens definidos en el Design System (no inventar tamaños/colores).

---

## Reglas técnicas

- Arquitectura: ver `docs/01_arquitectura.md`
- Reglas Codex: ver `docs/02_reglas_de_codex.md`

## Alcance

Incluye:
- Activar Realtime en Supabase para la tabla `notifications` (configuración manual documentada).
- Crear modelo de dominio `Notification` en `src/domain/models/Notification.ts`.
- Crear repositorio `INotificationRepository` e implementación en `src/infrastructure/repositories/NotificationRepository.ts`.
- Crear UseCase `GetNotificationsUseCase` para obtener notificaciones del usuario.
- Crear UseCase `MarkNotificationAsReadUseCase` para marcar notificaciones como leídas.
- Crear componente `NotificationBell` con menú flotante en `src/presentation/components/molecules/NotificationBell.tsx`.
- Integrar `NotificationBell` en `FoundationHeader` y `DashboardHeader`.
- Crear hook `useNotifications` para manejar suscripción a Realtime y estado de notificaciones.
- Actualizar `NeedsAttentionSection` para mostrar notificaciones relevantes.
- Agregar traducciones para todos los textos de notificaciones (ES/EN).
- Configurar suscripción a Realtime usando Supabase Realtime API.

No incluye:
- Notificaciones push del navegador (solo in-app).
- Notificaciones por email (ya manejado por `email_queue`).
- Sistema de preferencias de notificaciones (todos los tipos se muestran).
- Paginación avanzada en el menú de notificaciones (máximo 15 items).

---

## Criterios de aceptación (Given / When / Then)

### 1) Activación de Realtime en Supabase

- **Dado** que la tabla `notifications` existe en Supabase
- **Cuando** se active Realtime en el Dashboard de Supabase
- **Entonces** la tabla debe estar configurada para emitir eventos `INSERT` y `UPDATE`
- **Y** debe estar documentado en esta HU cómo activarlo

### 2) Icono de notificaciones con badge

- **Dado** un usuario foundation_user autenticado
- **Cuando** hay notificaciones no leídas
- **Entonces** el icono de campana en el header debe mostrar un badge con el número de no leídas
- **Y** el badge debe actualizarse en tiempo real cuando lleguen nuevas notificaciones

### 3) Menú flotante de notificaciones

- **Dado** el icono de notificaciones visible
- **Cuando** el usuario hace clic en el icono
- **Entonces** se abre un menú flotante (dropdown/popover) con las últimas notificaciones
- **Y** las notificaciones no leídas tienen un indicador visual (punto azul o fondo diferente)
- **Y** cada notificación muestra título, cuerpo truncado, y tiempo relativo
- **Y** el menú se cierra al hacer clic fuera o al seleccionar una notificación

### 4) Actualización en tiempo real

- **Dado** el dashboard abierto con el menú de notificaciones visible o cerrado
- **Cuando** se crea una nueva notificación en la base de datos (ej: nueva solicitud de adopción)
- **Entonces** el badge del icono se actualiza automáticamente sin recargar la página
- **Y** si el menú está abierto, la nueva notificación aparece en la parte superior
- **Y** no hay necesidad de hacer polling manual

### 5) Marcar como leída

- **Dado** una notificación no leída visible en el menú
- **Cuando** el usuario hace clic en la notificación
- **Entonces** la notificación se marca como leída en la base de datos
- **Y** el indicador visual de "no leída" desaparece
- **Y** el contador del badge se actualiza

### 6) Sección "Requiere Atención"

- **Dado** el dashboard con notificaciones no leídas
- **Cuando** se carga la sección "Requiere Atención"
- **Entonces** debe mostrar las notificaciones relevantes (filtradas por tipo o prioridad)
- **Y** las notificaciones deben actualizarse en tiempo real
- **Y** al hacer clic en una notificación, se marca como leída y se puede navegar al detalle

### 7) Traducciones

- **Dado** que la aplicación soporta ES/EN
- **Cuando** se muestran notificaciones
- **Entonces** todos los textos (títulos, mensajes, labels) deben estar traducidos
- **Y** los tiempos relativos deben respetar el locale del usuario

### 8) Seguridad y filtrado correcto

- **Dado** un usuario foundation_user autenticado con `user_id = UUID_A`
- **Cuando** se cargan o suscriben a notificaciones
- **Entonces** solo se muestran notificaciones donde `user_id = UUID_A`
- **Y** no se muestran notificaciones de otros usuarios (donde `user_id ≠ UUID_A`)
- **Y** el filtro `user_id=eq.${userId}` está aplicado en:
  - La query inicial de notificaciones
  - La suscripción a Realtime
  - Las operaciones de marcar como leída
- **Y** el repositorio valida que `user_id` coincida antes de marcar como leída

---

## Reglas técnicas

### Arquitectura
- Presentation solo consume UseCases vía IoC (no importa repositorios concretos).
- Domain no importa React/Next/MUI/Tailwind/Inversify.
- Infrastructure contiene implementaciones y wiring IoC.
- El hook `useNotifications` debe estar en `src/presentation/hooks/useNotifications.ts`.
- La suscripción a Realtime debe manejarse en el hook, no en componentes.

### UI (si aplica)
- UI con MUI (Popover, Badge, List, ListItem, etc.).
- Tailwind se usa para layout/spacing/responsive utilities.
- El menú flotante debe usar `Popover` o `Menu` de MUI.
- El badge debe usar `Badge` de MUI.
- No agregar librerías de estilos adicionales.

### Realtime
- Usar `supabaseClient.channel()` para suscribirse a cambios en `notifications`.
- **CRÍTICO**: Filtrar por `user_id = auth.uid()` en la suscripción para que cada usuario solo reciba sus propias notificaciones.
- Escuchar eventos `INSERT` y `UPDATE`.
- Limpiar la suscripción al desmontar el componente/hook.
- El filtro `user_id=eq.${userId}` asegura que:
  - Los foundation_users solo reciben notificaciones donde `user_id = su_user_id`
  - Los adoptantes solo reciben notificaciones donde `user_id = su_user_id`
  - No hay mezcla de notificaciones entre usuarios diferentes

### Traducciones (OBLIGATORIO si hay UI con texto)
- **TODOS los textos visibles en la UI deben estar traducidos** (español e inglés).
- Usar el sistema de traducciones configurado en HU-016 (`next-intl`).
- Agregar traducciones en:
  - `src/messages/es/notifications.json` (español)
  - `src/messages/en/notifications.json` (inglés)
- Keys sugeridas:
  - `notifications.bell.ariaLabel`
  - `notifications.menu.title`
  - `notifications.menu.empty`
  - `notifications.menu.markAllAsRead`
  - `notifications.menu.viewAll`
  - `notifications.time.ago` (para tiempos relativos)
  - `notifications.types.adoption_request_created`
  - `notifications.types.adoption_status_changed`
- Usar `useTranslations("notifications")` para acceder a traducciones.

### Dependencias / Paquetes
- No agregar dependencias nuevas (usar Supabase Realtime que ya está disponible).
- Si aparece error 403/conectividad:
  1) Detenerse
  2) Pedir dominios requeridos
  3) Explicar por qué se requieren
  4) No continuar

---

## Implementación sugerida (opcional)

### Configuración de Supabase Realtime (Manual)

1. Ir a Supabase Dashboard > Database > Replication
2. Buscar la tabla `notifications`
3. Activar Realtime para la tabla
4. Verificar que los eventos `INSERT` y `UPDATE` estén habilitados

### Archivos/carpetas sugeridas:

**Domain:**
- `src/domain/models/Notification.ts` - Modelo de Notification con campos:
  - `id: string` (UUID)
  - `userId: string` (UUID del usuario que recibe)
  - `actorUserId: string | null` (UUID del usuario que originó, puede ser null)
  - `title: string`
  - `body: string | null`
  - `type: string` (ej: 'adoption_request_created', 'adoption_status_changed')
  - `data: Record<string, unknown>` (JSONB parseado)
  - `readAt: string | null` (timestamp ISO o null)
  - `createdAt: string` (timestamp ISO)
- `src/domain/repositories/INotificationRepository.ts` - Interfaz del repositorio con métodos:
  - `getNotifications(userId: string, filters?, pagination?): Promise<Notification[]>`
  - `markAsRead(userId: string, notificationId: string): Promise<void>`
  - `markAllAsRead(userId: string): Promise<void>` (opcional)
  - `getUnreadCount(userId: string): Promise<number>`
- `src/domain/usecases/notifications/GetNotificationsUseCase.ts` - UseCase para obtener notificaciones del usuario autenticado
- `src/domain/usecases/notifications/MarkNotificationAsReadUseCase.ts` - UseCase para marcar como leída (verifica que user_id coincida)
- `src/domain/usecases/notifications/MarkAllNotificationsAsReadUseCase.ts` - UseCase para marcar todas como leídas (opcional)

**Infrastructure:**
- `src/infrastructure/repositories/NotificationRepository.ts` - Implementación del repositorio:
  - Usar `supabaseClient.from('notifications')` para queries
  - **Siempre filtrar por `user_id = userId`** en todas las queries (seguridad)
  - Mapear campos de BD a modelo de dominio:
    - `user_id` → `userId`
    - `actor_user_id` → `actorUserId`
    - `read_at` → `readAt`
    - `created_at` → `createdAt`
    - `data` (JSONB) → `data` (objeto parseado)
  - Para `markAsRead`: actualizar `read_at = now()` donde `id = notificationId AND user_id = userId`
- `src/infrastructure/ioc/usecases/notifications.types.ts` - Tipos para IoC
- Actualizar `src/infrastructure/ioc/container.ts` - Registrar UseCases

**Presentation:**
- `src/presentation/components/molecules/NotificationBell.tsx` - Componente del icono con menú:
  - Usa `useNotifications` hook para obtener notificaciones y suscribirse a Realtime
  - Muestra badge con contador de no leídas
  - Abre Popover/Menu al hacer clic
  - Maneja estado de apertura/cierre del menú
- `src/presentation/components/molecules/NotificationItem.tsx` - Componente individual de notificación:
  - Muestra título, cuerpo truncado, tiempo relativo
  - Indicador visual si no está leída (punto azul o fondo diferente)
  - Maneja clic para marcar como leída y navegar (si aplica)
- `src/presentation/hooks/useNotifications.ts` - Hook para manejar notificaciones y Realtime:
  - Obtiene `userId` del hook `useAuth()`
  - Carga notificaciones iniciales con `GetNotificationsUseCase`
  - Suscribe a Realtime con filtro `user_id=eq.${userId}`
  - Maneja estado local de notificaciones
  - Expone: `notifications`, `unreadCount`, `markAsRead`, `markAllAsRead`, `loading`
  - Limpia suscripción en cleanup
- `src/presentation/components/dashboard/NeedsAttentionSection.tsx` - Actualizar para mostrar notificaciones:
  - Filtrar notificaciones relevantes (por tipo o prioridad)
  - Mostrar notificaciones no leídas relacionadas con alertas
  - Integrar con Realtime para actualización automática
- `src/presentation/components/layouts/FoundationLayout/FoundationHeader.tsx` - Integrar NotificationBell
- `src/presentation/components/dashboard/DashboardHeader.tsx` - Integrar NotificationBell

**Traducciones:**
- `src/messages/es/notifications.json`
- `src/messages/en/notifications.json`

### Flujo de Realtime:

```typescript
// En useNotifications hook
// IMPORTANTE: userId debe ser auth.uid() del usuario autenticado
const channel = supabaseClient
  .channel('notifications')
  .on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'notifications',
      filter: `user_id=eq.${userId}` // Solo notificaciones donde user_id = usuario actual
    },
    (payload) => {
      // payload.new contiene la nueva notificación
      // Agregar nueva notificación al estado
      // Verificar que payload.new.user_id === userId por seguridad
    }
  )
  .on(
    'postgres_changes',
    {
      event: 'UPDATE',
      schema: 'public',
      table: 'notifications',
      filter: `user_id=eq.${userId}` // Solo actualizaciones de notificaciones del usuario actual
    },
    (payload) => {
      // payload.new contiene la notificación actualizada
      // Actualizar notificación existente en el estado
      // Útil cuando se marca como leída (read_at cambia)
    }
  )
  .subscribe();

// Limpiar suscripción al desmontar
return () => {
  channel.unsubscribe();
};
```

**Nota sobre el filtro:**
- El filtro `user_id=eq.${userId}` es aplicado por Supabase en el servidor, no en el cliente.
- Esto significa que solo se reciben eventos de notificaciones donde `user_id` coincide con el usuario autenticado.
- Es seguro y eficiente, ya que el filtrado ocurre antes de enviar el evento al cliente.

---

## Validación

Comandos mínimos:
- `npm run dev`
- `npm run build`

Verificaciones:
- El badge se actualiza en tiempo real cuando llegan nuevas notificaciones.
- El menú muestra notificaciones correctamente formateadas.
- Las notificaciones se marcan como leídas al hacer clic.
- La sección "Requiere Atención" muestra notificaciones relevantes.
- No hay memory leaks (suscripciones se limpian correctamente).
- Traducciones completas (ES/EN).
- **Seguridad**: Verificar que solo se muestran notificaciones del usuario autenticado (user_id = auth.uid()).
- **Realtime**: Verificar que el filtro `user_id=eq.${userId}` funciona correctamente (no se reciben notificaciones de otros usuarios).
- **Fundación**: Verificar que los foundation_users reciben notificaciones cuando hay miembros en `foundation_members`.

---

## Definición de Hecho

- [ ] Criterios de aceptación cumplidos
- [ ] `npm run dev` OK
- [ ] `npm run build` OK
- [ ] Sin violaciones de capas
- [ ] Sin cambios fuera del alcance
- [ ] Realtime activado en Supabase Dashboard (documentado)
- [ ] Suscripciones a Realtime funcionando correctamente
- [ ] No hay memory leaks (suscripciones se limpian)
- [ ] **Traducciones incluidas** (si aplica UI con texto):
  - [ ] Textos agregados en `src/messages/es/notifications.json`
  - [ ] Textos agregados en `src/messages/en/notifications.json`
  - [ ] Componentes usan `useTranslations` (no textos hardcodeados)
  - [ ] Keys consistentes entre idiomas
- Commit sugerido:
  `feat: add real-time notifications for foundation users`
