# HU-044 — Sistema de almacenamiento de archivos privados con Supabase Storage

**Como** desarrollador  
**Quiero** un sistema centralizado para almacenar archivos privados en Supabase Storage  
**Para** manejar documentos de solicitudes de adopción de forma segura con control de acceso

---

## Dependencias

- HU-001 (Next.js App Router)
- HU-011 (Conexión a Supabase configurada)
- HU-013 (Estrategia de roles y protección de rutas definida)
- HU-016 (Sistema de traducciones configurado)
- HU-043 (Sistema de almacenamiento de imágenes públicas implementado)
- Bucket `amg-private-files` creado en Supabase Storage (configuración manual)
- Políticas RLS configuradas para el bucket (configuración manual)

---

## Contexto / Notas

- Actualmente el código maneja documentos de solicitudes de adopción:
  - Usa el bucket `adoption_request_documents` (debe migrarse a `amg-private-files`)
  - Genera URLs públicas con `getPublicUrl()` (incorrecto para documentos privados)
  - Los documentos incluyen: documentos de identidad, fotos del hogar, cartillas de vacunación, otros
- Esta HU unifica el almacenamiento de archivos privados usando el bucket `amg-private-files` en Supabase Storage.
- **Solo para documentos privados**: documentos de solicitudes de adopción.
- **NO incluye**:
  - Imágenes públicas (productos, animales, eventos, logos) - ya cubierto en HU-043
  - Archivos internos de fundaciones (si se implementan en el futuro)
- El bucket debe estar configurado como **privado** en Supabase Dashboard.
- Los archivos deben ser accesibles solo mediante **signed URLs** con expiración.
- Control de acceso:
  - El adoptante puede ver sus propios documentos
  - Los miembros de la fundación pueden ver documentos de solicitudes de su fundación
  - Los documentos no deben ser accesibles públicamente
- Estructura de carpetas sugerida:
  - `adoption-requests/{foundationId}/{requestId}/` - Documentos de solicitudes

---

## Diseño (OBLIGATORIO si hay UI)

Referencias:
- Diseño: `docs/design/system.md`
- Componentes existentes que manejan documentos:
  - `src/presentation/components/adopt-modal/AdoptFormWizard.tsx`
  - `src/presentation/components/adoptions-admin/AdoptionRequestDocuments.tsx`

Reglas:
- El sistema debe ser transparente para los componentes de UI.
- Los componentes solo necesitan pasar `File` objects para upload y recibir URLs para acceso.
- Las signed URLs deben generarse automáticamente cuando se necesitan.
- El sistema debe manejar errores de forma amigable.
- Los documentos deben mostrarse con preview si son imágenes, o icono de descarga si son PDFs/otros.

---

## Reglas técnicas

- Arquitectura: ver `docs/01_arquitectura.md`
- Reglas Codex: ver `docs/02_reglas_de_codex.md`

## Alcance

Incluye:
- Crear servicio/repositorio centralizado para almacenamiento de archivos privados (`IPrivateFileStorage` e implementación)
- Crear UseCase para upload de archivos privados (`UploadPrivateFileUseCase`)
- Crear UseCase para obtener signed URLs (`GetPrivateFileUrlUseCase`)
- Definir estructura de carpetas en el bucket `amg-private-files`
- Migrar `AdoptionRequestRepository.uploadFile()` para usar el nuevo sistema
- Actualizar `AdoptionRequestRepository` para usar signed URLs en lugar de URLs públicas
- Actualizar componentes de UI para usar signed URLs al mostrar documentos
- Validación de archivos (formato, tamaño)
- Generación de signed URLs con expiración
- Manejo de errores de storage
- Control de acceso mediante políticas RLS

No incluye:
- Almacenamiento de imágenes públicas (ya cubierto en HU-043)
- Archivos internos de fundaciones
- Sistema de CDN o optimización de archivos
- Compresión automática de archivos
- Migración de archivos existentes en el bucket antiguo (solo nuevas subidas)

---

## Criterios de aceptación (Given / When / Then)

### 1) Servicio de almacenamiento implementado

- **Dado** que se necesita almacenar archivos privados
- **Cuando** se implementa el sistema
- **Entonces** existe una interfaz `IPrivateFileStorage` en `domain/repositories/`
- **Y** existe una implementación `PrivateFileStorage` en `infrastructure/repositories/`
- **Y** el servicio usa el bucket `amg-private-files` de Supabase Storage
- **Y** el servicio genera signed URLs automáticamente cuando se necesita acceso

### 2) Estructura de carpetas definida

- **Dado** que se suben documentos de solicitudes de adopción
- **Cuando** se almacenan en Supabase Storage
- **Entonces** los archivos se organizan en carpetas según tipo:
  - `adoption-requests/{foundationId}/{requestId}/` para documentos de solicitudes
- **Y** los nombres de archivo incluyen timestamp y tipo de documento para evitar colisiones

### 3) UseCase de upload implementado

- **Dado** que se necesita subir un archivo privado
- **Cuando** se implementa la lógica de negocio
- **Entonces** existe un UseCase `UploadPrivateFileUseCase` en `domain/usecases/storage/`
- **Y** el UseCase recibe: `file`, `type` (adoption-request), `foundationId`, `requestId`, `docType`
- **Y** el UseCase retorna la ruta del archivo (path, no URL pública)
- **Y** el UseCase valida formato y tamaño antes de subir

### 4) UseCase de signed URLs implementado

- **Dado** que se necesita acceder a un archivo privado
- **Cuando** se implementa la lógica de negocio
- **Entonces** existe un UseCase `GetPrivateFileUrlUseCase` en `domain/usecases/storage/`
- **Y** el UseCase recibe: `filePath`, `expiresIn` (opcional, default: 1 hora)
- **Y** el UseCase retorna una signed URL con expiración
- **Y** el UseCase valida que el usuario tiene permisos para acceder al archivo

### 5) Validación de archivos

- **Dado** que se intenta subir un archivo
- **Cuando** se valida antes del upload
- **Entonces** se valida que:
  - El formato es válido (PDF, PNG, JPG, JPEG, GIF, WEBP)
  - El tamaño no excede el límite (ej: 10MB para documentos)
  - El archivo no está vacío
- **Y** se retorna error descriptivo si la validación falla

### 6) Migración de AdoptionRequestRepository

- **Dado** que `AdoptionRequestRepository` ya tiene método de upload
- **Cuando** se migra al nuevo sistema
- **Entonces** `AdoptionRequestRepository.uploadFile()` usa `IPrivateFileStorage`
- **Y** se elimina el código duplicado de upload
- **Y** los archivos se almacenan en `adoption-requests/{foundationId}/{requestId}/`
- **Y** se guarda el path en lugar de URL pública en la base de datos
- **Y** el bucket `adoption_request_documents` ya no se usa (o se depreca)

### 7) Actualización de acceso a documentos

- **Dado** que se necesita mostrar documentos en la UI
- **Cuando** se actualiza el código
- **Entonces** `AdoptionRequestRepository.getRequestDetail()` obtiene paths de archivos
- **Y** se genera signed URL usando `GetPrivateFileUrlUseCase` cuando se necesita mostrar
- **Y** los componentes de UI usan signed URLs en lugar de URLs públicas
- **Y** las signed URLs tienen expiración (ej: 1 hora)

### 8) Control de acceso

- **Dado** que un usuario intenta acceder a un documento
- **Cuando** se genera una signed URL
- **Entonces** se valida que:
  - Si es adoptante: solo puede ver documentos de sus propias solicitudes
  - Si es foundation_user: solo puede ver documentos de solicitudes de su fundación
  - Si no tiene permisos: se retorna error de acceso denegado
- **Y** las políticas RLS en Supabase también validan el acceso

### 9) Signed URLs con expiración

- **Dado** que se genera una signed URL
- **Cuando** se crea la URL
- **Entonces** la URL tiene un tiempo de expiración (default: 1 hora)
- **Y** la URL incluye firma criptográfica de Supabase
- **Y** después de expirar, la URL ya no funciona
- **Y** se puede regenerar una nueva signed URL si es necesario

### 10) Actualización de componentes de UI

- **Dado** que los componentes muestran documentos
- **Cuando** se actualiza el código
- **Entonces** `AdoptionRequestDocuments` usa signed URLs para mostrar documentos
- **Y** las signed URLs se generan cuando se renderiza el componente
- **Y** se maneja la expiración de URLs (regenerar si es necesario)
- **Y** los previews de imágenes funcionan correctamente con signed URLs

### 11) Manejo de errores

- **Dado** que puede fallar el upload o acceso de archivos
- **Cuando** ocurre un error
- **Entonces** se manejan los siguientes casos:
  - Error de conexión → "No se pudo conectar al servidor de almacenamiento"
  - Archivo muy grande → "El archivo excede el tamaño máximo permitido"
  - Formato inválido → "El formato de archivo no es válido"
  - Error de permisos → "No tienes permisos para acceder a este archivo"
  - URL expirada → "El enlace ha expirado, recargando..."
- **Y** los mensajes de error están traducidos (ES/EN)
- **Y** los errores se propagan correctamente a los componentes

### 12) Traducciones

- **Dado** que la aplicación soporta ES/EN
- **Cuando** se muestran mensajes relacionados con archivos privados
- **Entonces** todos los textos están traducidos:
  - Mensajes de error de upload
  - Mensajes de validación
  - Mensajes de acceso denegado
- **Y** los textos están en `src/messages/es/storage.json` y `src/messages/en/storage.json`
- **Y** se usa `useTranslations` para acceder a traducciones

---

## Reglas técnicas

### Arquitectura
- Presentation solo consume UseCases vía IoC (no importa repositorios concretos).
- Domain no importa React/Next/MUI/Tailwind/Inversify/Supabase.
- Infrastructure contiene implementaciones y wiring IoC.
- El servicio de storage debe estar en Infrastructure, la interfaz en Domain.

### Estructura de carpetas en Supabase Storage

```
amg-private-files/
└── adoption-requests/
    └── {foundationId}/
        └── {requestId}/
            ├── id-document-{timestamp}-{sanitized-filename}
            ├── home-{index}-{timestamp}-{sanitized-filename}
            ├── vaccination-card-{timestamp}-{sanitized-filename}
            └── other-{timestamp}-{sanitized-filename}
```

### Validación de archivos
- Formatos permitidos: `application/pdf`, `image/png`, `image/jpeg`, `image/jpg`, `image/gif`, `image/webp`
- Tamaño máximo: 10MB por archivo (más grande que imágenes públicas porque pueden ser PDFs)
- Validar MIME type del archivo
- Sanitizar nombres de archivo (eliminar caracteres especiales, espacios, etc.)

### Generación de nombres de archivo
- Formato: `{docType}-{timestamp}-{sanitized-filename}`
- Timestamp: `Date.now()` o `new Date().toISOString().replace(/[:.]/g, '-')`
- Sanitizar: convertir a lowercase, reemplazar espacios y caracteres especiales por guiones
- Ejemplo: `"Mi Documento.pdf"` → `"id-document-1234567890-mi-documento.pdf"`

### Signed URLs
- Usar `supabaseClient.storage.from(bucketName).createSignedUrl(path, expiresIn)` donde `bucketName` viene de la configuración
- Tiempo de expiración default: 3600 segundos (1 hora)
- Las signed URLs deben regenerarse cuando expiran
- No almacenar signed URLs en la base de datos (generarlas bajo demanda)

### Control de acceso
- Validar permisos antes de generar signed URL:
  - Adoptante: `adopter_user_id === current_user_id`
  - Foundation user: `foundation_id` coincide con la fundación del usuario
- Las políticas RLS en Supabase también deben validar acceso
- Si no tiene permisos, retornar error sin generar URL

### Almacenamiento en BD
- Guardar el **path** del archivo en `adoption_request_documents.file_url` (no la URL completa)
- El path debe ser relativo al bucket: `adoption-requests/{foundationId}/{requestId}/{filename}`
- Generar signed URL cuando se necesita mostrar el documento

### Manejo de errores
- Los errores de Supabase Storage deben traducirse a mensajes amigables.
- Usar códigos de error de Supabase para identificar tipos de error.
- Los mensajes de error deben estar en los archivos de traducción.

### Traducciones (OBLIGATORIO si hay UI con texto)
- **TODOS los textos visibles en la UI deben estar traducidos** (español e inglés).
- Usar el sistema de traducciones configurado en HU-016 (`next-intl`).
- Agregar traducciones en:
  - `src/messages/es/storage.json` (español)
  - `src/messages/en/storage.json` (inglés)
- Keys sugeridas (agregar a las de HU-043):
  - `storage.private.upload.success`
  - `storage.private.upload.error.accessDenied`
  - `storage.private.url.expired`
  - `storage.private.url.error.generating`
  - `storage.private.validation.maxSize` (10MB)
- Usar `useTranslations("storage")` para acceder a traducciones.

### Configuración de nombres de buckets
- Los nombres de buckets deben configurarse en variables de entorno o en el archivo de configuración.
- Agregar función en `src/infrastructure/config/environment.ts`:
  ```typescript
  export function getPrivateFilesBucket(): string {
    return process.env.NEXT_PUBLIC_SUPABASE_PRIVATE_FILES_BUCKET || 'amg-private-files';
  }
  ```
- O usar constante en el repositorio si no se requiere configuración por entorno:
  ```typescript
  const PRIVATE_FILES_BUCKET = 'amg-private-files';
  ```
- Si se usa variable de entorno, agregar a `.env.example`:
  ```bash
  NEXT_PUBLIC_SUPABASE_PRIVATE_FILES_BUCKET=amg-private-files
  ```
- El valor por defecto debe ser `'amg-private-files'` si no se especifica la variable.
- **Nota**: Aunque el bucket es privado, el nombre puede estar en `NEXT_PUBLIC_` porque no expone información sensible, solo el nombre del bucket.

### Dependencias / Paquetes
- No agregar dependencias nuevas salvo que esta HU lo indique explícitamente.
- Usar Supabase Storage que ya está disponible.
- Si aparece error 403/conectividad:
  1) Detenerse
  2) Pedir dominios requeridos
  3) Explicar por qué se requieren
  4) No continuar

---

## Implementación sugerida (opcional)

### Estructura de archivos sugerida:

```
src/domain/
├── repositories/
│   └── IPrivateFileStorage.ts (nuevo)
└── usecases/
    └── storage/
        ├── UploadPrivateFileUseCase.ts (nuevo)
        └── GetPrivateFileUrlUseCase.ts (nuevo)

src/infrastructure/
├── repositories/
│   └── PrivateFileStorage.ts (nuevo)
└── ioc/
    └── container.ts (registrar UseCases)

src/infrastructure/
└── repositories/
    └── AdoptionRequestRepository.ts (modificar)
```

### Flujo de implementación:

1. **Configurar nombres de buckets**:
   - Agregar función `getPrivateFilesBucket()` en `src/infrastructure/config/environment.ts`
   - O usar constante `PRIVATE_FILES_BUCKET = 'amg-private-files'` en el repositorio
   - Si se usa variable de entorno, agregar a `.env.example`

2. **Crear interfaz del repositorio**:
   ```typescript
   // IPrivateFileStorage.ts
   export type PrivateFileType = 'adoption-request';
   
   export interface UploadPrivateFileParams {
     file: File;
     type: PrivateFileType;
     foundationId: string;
     requestId: number;
     docType: string; // 'id-document', 'home-1', 'vaccination-card', 'other'
   }
   
   export interface GetPrivateFileUrlParams {
     filePath: string;
     expiresIn?: number; // segundos, default: 3600
   }
   
   export interface IPrivateFileStorage {
     uploadFile(params: UploadPrivateFileParams): Promise<string>; // Retorna path
     getSignedUrl(params: GetPrivateFileUrlParams): Promise<string>; // Retorna signed URL
   }
   ```

2. **Implementar repositorio**:
   ```typescript
   // PrivateFileStorage.ts
   class PrivateFileStorage implements IPrivateFileStorage {
     async uploadFile({ file, type, foundationId, requestId, docType }: UploadPrivateFileParams): Promise<string> {
       // Validar formato y tamaño
       this.validateFile(file);
       
       // Generar ruta según tipo
       const path = this.generatePath(type, foundationId, requestId, docType, file.name);
       
       // Subir a Supabase Storage (usar constante o función de configuración)
       const bucketName = getPrivateFilesBucket(); // o usar constante
       const { data, error } = await supabaseClient.storage
         .from(bucketName)
         .upload(path, file, { upsert: false });
       
       if (error) throw new Error(this.translateError(error));
       
       // Retornar path (no URL)
       return path;
     }
     
     async getSignedUrl({ filePath, expiresIn = 3600 }: GetPrivateFileUrlParams): Promise<string> {
       const bucketName = getPrivateFilesBucket(); // o usar constante
       const { data, error } = await supabaseClient.storage
         .from(bucketName)
         .createSignedUrl(filePath, expiresIn);
       
       if (error) throw new Error(this.translateError(error));
       
       return data.signedUrl;
     }
     
     private validateFile(file: File): void {
       // Validar formato, tamaño, etc.
     }
     
     private generatePath(type: PrivateFileType, foundationId: string, requestId: number, docType: string, fileName: string): string {
       const sanitized = this.sanitizeFileName(fileName);
       const timestamp = Date.now();
       return `${type}s/${foundationId}/${requestId}/${docType}-${timestamp}-${sanitized}`;
     }
     
     private sanitizeFileName(fileName: string): string {
       return fileName
         .replace(/[^a-z0-9.\-_]/gi, '-')
         .toLowerCase();
     }
   }
   ```

3. **Crear UseCases**:
   ```typescript
   // UploadPrivateFileUseCase.ts
   export class UploadPrivateFileUseCase {
     constructor(private readonly fileStorage: IPrivateFileStorage) {}
     
     async execute(params: UploadPrivateFileParams): Promise<string> {
       return await this.fileStorage.uploadFile(params);
     }
   }
   
   // GetPrivateFileUrlUseCase.ts
   export class GetPrivateFileUrlUseCase {
     constructor(
       private readonly fileStorage: IPrivateFileStorage,
       private readonly authRepository: IAuthRepository,
       // Repositorio para validar permisos
     ) {}
     
     async execute(params: GetPrivateFileUrlParams & { requestId: number }): Promise<string> {
       // Validar permisos antes de generar URL
       await this.validateAccess(params.requestId);
       
       return await this.fileStorage.getSignedUrl({ filePath: params.filePath, expiresIn: params.expiresIn });
     }
     
     private async validateAccess(requestId: number): Promise<void> {
       // Validar que el usuario tiene permisos para acceder a esta solicitud
       // Adoptante: verificar que es su solicitud
       // Foundation user: verificar que es de su fundación
     }
   }
   ```

5. **Registrar en IoC**:
   - Agregar `IPrivateFileStorage` y `PrivateFileStorage` al contenedor
   - Registrar `UploadPrivateFileUseCase` y `GetPrivateFileUrlUseCase`

6. **Migrar AdoptionRequestRepository**:
   - Reemplazar `uploadFile()` para usar `IPrivateFileStorage`
   - Guardar paths en lugar de URLs en la BD
   - Actualizar `getRequestDetail()` para obtener paths y generar signed URLs cuando se necesiten

7. **Actualizar componentes de UI**:
   - `AdoptionRequestDocuments`: generar signed URLs al renderizar
   - Manejar expiración de URLs (regenerar si es necesario)
   - Mostrar previews correctamente con signed URLs

### Configuración de Supabase Storage (Manual)

1. Ir a Supabase Dashboard > Storage
2. Crear bucket `amg-private-files` si no existe (o el nombre configurado en la variable de entorno)
3. Configurar como **privado** (NO público)
4. (Opcional) Configurar variable de entorno `NEXT_PUBLIC_SUPABASE_PRIVATE_FILES_BUCKET` si se desea usar un nombre diferente
5. Configurar políticas RLS:
   - Adoptantes pueden leer archivos de sus propias solicitudes
   - Foundation users pueden leer archivos de solicitudes de su fundación
   - Solo el sistema puede escribir archivos (upload)

### Políticas RLS sugeridas (SQL):

```sql
-- Permitir lectura a adoptantes de sus propios documentos
CREATE POLICY "Adopters can read their own documents"
ON storage.objects FOR SELECT
USING (
  bucket_id = 'amg-private-files' AND
  (storage.foldername(name))[1] = 'adoption-requests' AND
  EXISTS (
    SELECT 1 FROM adoption_requests ar
    WHERE ar.id::text = (storage.foldername(name))[3]
    AND ar.adopter_user_id = auth.uid()
  )
);

-- Permitir lectura a foundation users de documentos de su fundación
CREATE POLICY "Foundation users can read their foundation documents"
ON storage.objects FOR SELECT
USING (
  bucket_id = 'amg-private-files' AND
  (storage.foldername(name))[1] = 'adoption-requests' AND
  EXISTS (
    SELECT 1 FROM adoption_requests ar
    JOIN foundation_members fm ON fm.foundation_id = ar.foundation_id
    WHERE ar.id::text = (storage.foldername(name))[3]
    AND ar.foundation_id::text = (storage.foldername(name))[2]
    AND fm.user_id = auth.uid()
  )
);

-- Permitir upload solo a usuarios autenticados (el sistema controla permisos)
CREATE POLICY "Authenticated users can upload documents"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'amg-private-files' AND
  auth.role() = 'authenticated'
);
```

### Notas importantes:
- El bucket debe estar configurado como **privado** (no público).
- Las políticas RLS deben validar acceso antes de permitir lectura.
- Los paths se guardan en la BD, las signed URLs se generan bajo demanda.
- Las signed URLs expiran después de 1 hora (configurable).
- No almacenar signed URLs en la BD (siempre generarlas cuando se necesiten).

---

## Validación

Comandos mínimos:
- `npm run dev` (verificar que el upload funciona)
- `npm run build` (verificar que no hay errores de compilación)

Verificaciones:
- Los archivos se suben correctamente a `amg-private-files`
- Los paths se guardan correctamente en la base de datos
- Las signed URLs se generan correctamente cuando se necesitan
- Los archivos se organizan en las carpetas correctas
- La validación de formato y tamaño funciona
- El control de acceso funciona (adoptante solo ve sus documentos, foundation solo ve de su fundación)
- Los errores se manejan correctamente y se muestran mensajes traducidos
- `AdoptionRequestRepository` usa el nuevo sistema
- Los componentes de UI usan signed URLs correctamente
- Las traducciones están completas (ES/EN)
- El bucket está configurado como privado en Supabase
- Las políticas RLS están configuradas correctamente

---

## Definición de Hecho

- [ ] Criterios de aceptación cumplidos
- [ ] `npm run dev` OK
- [ ] `npm run build` OK
- [ ] Sin violaciones de capas
- [ ] Sin cambios fuera del alcance
- [ ] **Traducciones incluidas** (si aplica UI con texto):
  - [ ] Textos agregados en `src/messages/es/storage.json`
  - [ ] Textos agregados en `src/messages/en/storage.json`
  - [ ] Componentes usan `useTranslations` (no textos hardcodeados)
  - [ ] Keys consistentes entre idiomas
- [ ] Servicio de storage privado creado e implementado
- [ ] UseCases de upload y signed URLs creados y registrados en IoC
- [ ] `AdoptionRequestRepository` migrado al nuevo sistema
- [ ] Componentes de UI actualizados para usar signed URLs
- [ ] Validación de archivos implementada
- [ ] Control de acceso implementado
- [ ] Bucket `amg-private-files` configurado como privado en Supabase
- [ ] Políticas RLS configuradas correctamente
- [ ] Estructura de carpetas implementada correctamente
- Commit sugerido:
  `feat: implement private file storage with Supabase Storage for adoption requests`
