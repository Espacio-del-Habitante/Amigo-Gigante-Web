# HU-046 — Eliminación de imágenes de productos desde Supabase Storage

**Como** miembro de fundación  
**Quiero** que las imágenes antiguas de productos se eliminen automáticamente cuando se carga una nueva  
**Para** evitar acumulación de archivos no utilizados en el storage y mantener el almacenamiento optimizado

---

## Dependencias

- HU-001 (Next.js App Router)
- HU-011 (Conexión a Supabase configurada)
- HU-016 (Sistema de traducciones configurado)
- HU-030 (Crear productos implementado)
- HU-043 (Sistema de almacenamiento de imágenes públicas implementado)
- HU-045 (Eliminación de imágenes de animales implementada - para reutilizar `DeletePublicImageUseCase`)
- Bucket `amg-public-image` creado en Supabase Storage (configuración manual)

---

## Contexto / Notas

- Actualmente, cuando se edita un producto y se carga una nueva imagen:
  - La nueva imagen se sube correctamente a Supabase Storage ✅
  - La URL se actualiza en la tabla `products` ✅
  - **PERO la imagen anterior NO se elimina de Supabase Storage** ❌
  - Esto causa acumulación rápida de archivos huérfanos en el storage
- Cuando se elimina un producto completo:
  - El producto se elimina de la tabla `products` ✅
  - **PERO la imagen NO se elimina de Supabase Storage** ❌
- Esta HU implementa:
  - Eliminación automática de la imagen anterior cuando se carga una nueva en edición
  - Eliminación de la imagen cuando se elimina un producto completo
- **Solo para imágenes de productos** almacenadas en `amg-public-image/products/{foundationId}/`
- **NO incluye**:
  - Eliminación de imágenes de animales (ya cubierto en HU-045)
  - Eliminación de imágenes de eventos o logos de fundaciones
  - Limpieza masiva de archivos huérfanos existentes (puede ser script separado)

---

## Diseño (OBLIGATORIO si hay UI)

Referencias:
- Diseño: `docs/design/system.md`
- Componentes existentes:
  - `src/presentation/components/products/EditProductForm.tsx`
  - `src/presentation/components/products/ProductForm.tsx`

Reglas:
- La eliminación debe ser transparente para el usuario
- No se requiere confirmación adicional
- Los errores de eliminación deben manejarse de forma amigable
- Si falla la eliminación del storage pero se actualiza la imagen, registrar el error pero no bloquear la operación

---

## Reglas técnicas

- Arquitectura: ver `docs/01_arquitectura.md`
- Reglas Codex: ver `docs/02_reglas_de_codex.md`

## Alcance

Incluye:
- Reutilizar `DeletePublicImageUseCase` creado en HU-045
- Modificar `UpdateProductUseCase` para:
  - Obtener la imagen actual del producto antes de actualizar
  - Detectar si se está reemplazando la imagen (nuevo `imageFile` o nueva `imageUrl`)
  - Eliminar la imagen anterior del storage antes de subir la nueva
- Modificar `DeleteProductUseCase` para:
  - Obtener la imagen del producto antes de eliminarlo
  - Eliminar la imagen del storage
- Manejo de errores al eliminar (no bloquear la operación principal si falla)
- Validar que la imagen anterior pertenece a Supabase Storage antes de intentar eliminarla

No incluye:
- Eliminación de imágenes de animales, eventos o logos
- Limpieza masiva de archivos huérfanos existentes
- Sistema de soft-delete o recuperación de imágenes eliminadas
- Confirmación adicional en la UI

---

## Criterios de aceptación (Given / When / Then)

### 1) Eliminación de imagen anterior al actualizar producto

- **Dado** que un usuario edita un producto y carga una nueva imagen
- **Cuando** se guarda el formulario
- **Entonces** `UpdateProductUseCase` obtiene la imagen actual del producto
- **Y** detecta que se está reemplazando la imagen (hay `imageFile` nuevo o `imageUrl` diferente)
- **Y** elimina la imagen anterior del storage usando `DeletePublicImageUseCase` (si pertenece a Supabase Storage)
- **Y** sube la nueva imagen al storage
- **Y** actualiza la URL en la tabla `products`
- **Y** si falla la eliminación del storage, se registra el error pero no se bloquea la operación

### 2) Validación de URLs de Supabase Storage

- **Dado** que se tiene una URL de imagen de producto
- **Cuando** se necesita eliminar la imagen
- **Entonces** se valida que la URL pertenece al bucket `amg-public-image`
- **Y** se valida que la URL pertenece a la carpeta `products/`
- **Y** si la URL es externa (no de Supabase Storage), no se intenta eliminar
- **Y** se retorna sin error si la URL es externa

### 3) Eliminación de imagen al eliminar producto completo

- **Dado** que un usuario elimina un producto completo
- **Cuando** se ejecuta `DeleteProductUseCase`
- **Entonces** se obtiene la imagen del producto antes de eliminarlo
- **Y** se elimina la imagen del storage usando `DeletePublicImageUseCase` (si pertenece a Supabase Storage)
- **Y** se elimina el producto de la tabla `products`
- **Y** si falla la eliminación del storage, se registra el error pero se continúa con la eliminación del producto

### 4) Manejo de errores

- **Dado** que se intenta eliminar una imagen de producto
- **Cuando** ocurre un error (archivo no existe, sin permisos, etc.)
- **Entonces** el error se registra pero no se propaga como excepción crítica
- **Y** la operación principal (actualizar/eliminar producto) continúa normalmente
- **Y** no se muestra mensaje de error al usuario (la operación principal fue exitosa)

### 5) Casos especiales

- **Dado** que un producto no tiene imagen (`image_url` es `null`)
- **Cuando** se actualiza o elimina el producto
- **Entonces** no se intenta eliminar ninguna imagen
- **Y** la operación continúa normalmente

- **Dado** que un producto tiene una URL externa (no de Supabase Storage)
- **Cuando** se reemplaza o elimina el producto
- **Entonces** no se intenta eliminar la imagen del storage
- **Y** la operación continúa normalmente

---

## Reglas técnicas

### Arquitectura
- Presentation solo consume UseCases vía IoC (no importa repositorios concretos).
- Domain no importa React/Next/MUI/Tailwind/Inversify/Supabase.
- Infrastructure contiene implementaciones y wiring IoC.
- Reutilizar `DeletePublicImageUseCase` creado en HU-045.

### Estructura de eliminación en UpdateProductUseCase

```typescript
// domain/usecases/products/UpdateProductUseCase.ts
export class UpdateProductUseCase {
  constructor(
    private readonly productRepository: IProductRepository,
    private readonly authRepository: IAuthRepository,
    private readonly foundationMembershipRepository: IFoundationMembershipRepository,
    private readonly deletePublicImageUseCase: DeletePublicImageUseCase,
  ) {}
  
  async execute(input: UpdateProductInput): Promise<void> {
    // ... código existente para obtener foundationId, etc.
    
    // Obtener producto actual ANTES de hacer cambios
    const currentProduct = await this.productRepository.getProductById({
      productId: input.productId,
      foundationId,
    });
    const currentImageUrl = currentProduct.imageUrl;
    
    // Determinar si se está reemplazando la imagen
    const isReplacingImage = 
      (input.imageFile !== null && input.imageFile !== undefined) || // Nuevo archivo
      (input.imageUrl !== null && input.imageUrl !== currentImageUrl); // Nueva URL diferente
    
    // Si se está reemplazando y hay una imagen anterior de Supabase Storage, eliminarla
    if (isReplacingImage && currentImageUrl) {
      await this.deletePublicImageUseCase.execute({ url: currentImageUrl })
        .catch(error => {
          // Log error pero no bloquear operación
          console.error('Error deleting old product image:', error);
        });
    }
    
    // Continuar con actualización normal (subir nueva imagen si hay imageFile)
    await this.productRepository.updateProduct({
      // ... parámetros existentes
    });
  }
}
```

### Estructura de eliminación en DeleteProductUseCase

```typescript
// domain/usecases/products/DeleteProductUseCase.ts
export class DeleteProductUseCase {
  constructor(
    private readonly productRepository: IProductRepository,
    private readonly authRepository: IAuthRepository,
    private readonly foundationMembershipRepository: IFoundationMembershipRepository,
    private readonly deletePublicImageUseCase: DeletePublicImageUseCase,
  ) {}
  
  async execute(input: DeleteProductInput): Promise<void> {
    const session = await this.authRepository.getSession();
    if (!session?.user?.id) {
      throw new Error("errors.unauthorized");
    }
    
    const foundationId = await this.foundationMembershipRepository.getFoundationIdForUser(session.user.id);
    
    // Obtener producto ANTES de eliminarlo para obtener la imagen
    const product = await this.productRepository.getProductById({
      productId: input.productId,
      foundationId,
    });
    
    // Eliminar imagen del storage si existe y pertenece a Supabase Storage
    if (product.imageUrl) {
      await this.deletePublicImageUseCase.execute({ url: product.imageUrl })
        .catch(error => {
          // Log error pero no bloquear eliminación del producto
          console.error('Error deleting product image:', error);
        });
    }
    
    // Eliminar el producto
    await this.productRepository.deleteProduct({
      foundationId,
      productId: input.productId,
    });
  }
}
```

### Traducciones (OBLIGATORIO si hay UI con texto)

- Las traducciones ya están en `storage.json` (creadas en HU-045)
- No se requieren traducciones adicionales ya que los errores se manejan internamente
- Si en el futuro se decide mostrar mensajes, usar las keys existentes:
  - `storage.delete.error.generic`
  - `storage.delete.error.notFound`
  - `storage.delete.error.permissionDenied`

---

## Implementación sugerida

### 1. Modificar UpdateProductUseCase

```typescript
// domain/usecases/products/UpdateProductUseCase.ts
import { DeletePublicImageUseCase } from "@/domain/usecases/storage/DeletePublicImageUseCase";

export class UpdateProductUseCase {
  constructor(
    private readonly productRepository: IProductRepository,
    private readonly authRepository: IAuthRepository,
    private readonly foundationMembershipRepository: IFoundationMembershipRepository,
    private readonly deletePublicImageUseCase: DeletePublicImageUseCase,
  ) {}
  
  async execute(input: UpdateProductInput): Promise<void> {
    const session = await this.authRepository.getSession();
    if (!session?.user?.id) {
      throw new Error("errors.unauthorized");
    }
    
    if (!Number.isFinite(input.price)) {
      throw new Error("errors.generic");
    }
    
    const foundationId = await this.foundationMembershipRepository.getFoundationIdForUser(session.user.id);
    
    // Obtener producto actual ANTES de hacer cambios
    const currentProduct = await this.productRepository.getProductById({
      productId: input.productId,
      foundationId,
    });
    const currentImageUrl = currentProduct.imageUrl;
    
    // Determinar si se está reemplazando la imagen
    const hasNewFile = input.imageFile !== null && input.imageFile !== undefined;
    const hasNewUrl = input.imageUrl !== null && input.imageUrl.trim() !== "";
    const isDifferentUrl = hasNewUrl && input.imageUrl !== currentImageUrl;
    const isReplacingImage = hasNewFile || isDifferentUrl;
    
    // Si se está reemplazando y hay una imagen anterior de Supabase Storage, eliminarla
    if (isReplacingImage && currentImageUrl) {
      await this.deletePublicImageUseCase.execute({ url: currentImageUrl })
        .catch(error => {
          // Log error pero no bloquear operación
          console.error('Error deleting old product image from storage:', error);
        });
    }
    
    // Continuar con actualización normal
    await this.productRepository.updateProduct({
      foundationId,
      productId: input.productId,
      name: input.name,
      description: input.description,
      price: input.price,
      imageUrl: input.imageUrl,
      imageFile: input.imageFile ?? null,
      isPublished: input.isPublished,
    });
  }
}
```

### 2. Modificar DeleteProductUseCase

```typescript
// domain/usecases/products/DeleteProductUseCase.ts
import { DeletePublicImageUseCase } from "@/domain/usecases/storage/DeletePublicImageUseCase";

export class DeleteProductUseCase {
  constructor(
    private readonly productRepository: IProductRepository,
    private readonly authRepository: IAuthRepository,
    private readonly foundationMembershipRepository: IFoundationMembershipRepository,
    private readonly deletePublicImageUseCase: DeletePublicImageUseCase,
  ) {}
  
  async execute(input: DeleteProductInput): Promise<void> {
    const session = await this.authRepository.getSession();
    if (!session?.user?.id) {
      throw new Error("errors.unauthorized");
    }
    
    const foundationId = await this.foundationMembershipRepository.getFoundationIdForUser(session.user.id);
    
    // Obtener producto ANTES de eliminarlo para obtener la imagen
    const product = await this.productRepository.getProductById({
      productId: input.productId,
      foundationId,
    });
    
    // Eliminar imagen del storage si existe
    if (product.imageUrl) {
      await this.deletePublicImageUseCase.execute({ url: product.imageUrl })
        .catch(error => {
          // Log error pero no bloquear eliminación del producto
          console.error('Error deleting product image from storage:', error);
        });
    }
    
    // Eliminar el producto
    await this.productRepository.deleteProduct({
      foundationId,
      productId: input.productId,
    });
  }
}
```

### 3. Registrar DeletePublicImageUseCase en IoC (si no está ya registrado de HU-045)

- Verificar que `DeletePublicImageUseCase` esté registrado en el contenedor IoC
- Si no está, agregarlo en `usecases.types.ts` y `usecases.container.ts`

### 4. Actualizar dependencias en los UseCases

- Agregar `DeletePublicImageUseCase` como dependencia en `UpdateProductUseCase`
- Agregar `DeletePublicImageUseCase` como dependencia en `DeleteProductUseCase`

---

## Validación

Comandos mínimos:
- `npm run dev` (verificar que la eliminación funciona)
- `npm run build` (verificar que no hay errores de compilación)

Pruebas manuales:
1. Editar un producto con imagen existente
2. Cargar una nueva imagen
3. Guardar el formulario
4. Verificar en Supabase Dashboard > Storage que la imagen anterior se eliminó del bucket
5. Verificar que la nueva imagen se subió correctamente
6. Verificar que la URL en la BD se actualizó
7. Eliminar un producto completo con imagen
8. Verificar en Supabase Dashboard > Storage que la imagen se eliminó del bucket
9. Verificar que el producto se eliminó de la BD

---

## Definición de Hecho

- [ ] Criterios de aceptación cumplidos
- [ ] `npm run dev` OK
- [ ] `npm run build` OK
- [ ] Sin violaciones de capas
- [ ] Sin cambios fuera del alcance
- [ ] Reutiliza `DeletePublicImageUseCase` de HU-045 (no duplicar código)
- [ ] Pruebas manuales realizadas:
  - [ ] Eliminación de imagen anterior al actualizar producto funciona
  - [ ] Las imágenes se eliminan del storage
  - [ ] Las URLs se actualizan correctamente en la BD
  - [ ] Eliminación de imagen al eliminar producto funciona
  - [ ] Los errores se manejan sin bloquear la operación
- Commit sugerido:
  `feat: implementar eliminación automática de imágenes de productos (HU-046)`
